type index;
fun tuple(msg, msg):msg

type session


fun sel1of2(msg):msg;
fun sel2of2(msg):msg
fun hash(msg, msg):msg
fun ok:msg
fun ko:msg

/* the nonces */
fun nt(session, index): nonce
fun nr(session): nonce
fun key(index):nonce

step reader1(i:session) 
    {true}
    {nr(i)}

step reader2(i:session)
    {true}
    {
        try find (j:index)
            such that {
                ( hash(tuple(nr(i),sel1of2(input(reader2(i)))), key(j)) 
                    == sel2of2(input(reader2(i))) )
            } then { ok } else { ko }
    }

step tag(i:session, j:index)
    {true}
    {tuple(
        nt(i,j),
        hash(
            tuple(input(tag(i,j)),nt(i,j)),
            key(j)
        )
    )}

assert
    forall (m1:msg, m2:msg) {
        ((m1 == sel1of2(tuple(m1,m2))) &&
        (m1 == sel1of2(tuple(m1,m2))))
    }

order forall (bijour:session) 
    reader1(bijour) < reader2(bijour)

query false