type index;
fun tuple(Message, Message):Message

type session


fun sel1of2(Message):Message;
fun sel2of2(Message):Message
fun hash(Message, Message):Message
fun ok:Message
fun ko:Message

/* the Nonces */
fun nt(session, index): Nonce
fun nr(session): Nonce
fun key(index):Nonce

step reader1(i:session) 
    {true}
    {nr(i)}

step reader2(i:session)
    {true}
    {
        try find (j:index)
            such that {
                ( hash(tuple(nr(i),sel1of2(input(reader2(i)))), key(j)) 
                    == sel2of2(input(reader2(i))) )
            } then { ok } else { ko }
    }

step tag(i:session, j:index)
    {true}
    {tuple(
        nt(i,j),
        hash(
            tuple(input(tag(i,j)),nt(i,j)),
            key(j)
        )
    )}

assert
    forall (m1:Message, m2:Message) {
        ((m1 == sel1of2(tuple(m1,m2))) &&
        (m2 == sel2of2(tuple(m1,m2))))
    }

order forall (bijour:session) 
    reader1(bijour) < reader2(bijour)

query false

assert-crypto euf-cma-hash hash;