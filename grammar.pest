content = {SOI ~ (
        ( declaration | step | assertion 
            | order | query | lemma 
            | assertion_crypto 
        ) ~ EOL)*  ~ EOI}

WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
EOL = _{ ";" | NEWLINE }

ident = @{  ASCII_ALPHA ~ ( ASCII_ALPHANUMERIC | "_" | "-")* }
underscore = {"_"}


type_name = @{ident}
function = @{ident}
variable = @{underscore? ~ ident}
step_name = @{ident}
operation = _{ eq | neq | or | and }
    eq = { "==" }
    neq = { "!=" | "<>" }
    or = { "||" }
    and = { "&&" }

typed_arguments = {("(" ~ (variable_binding ~ ",")* ~ variable_binding? ~ ")")?}
    variable_binding = {variable ~ ":" ~ type_name }

commun_base = { if_then_else | find_such_that | quantifier | application } 
term = { /* "(" ~ inner_term ~ ")" | */ inner_term }
    inner_term = { commun_base | infix_term}
bracketed_term = _{"{" ~ term ~ "}"}

infix_term = {"(" ~ term ~ (operation ~ term)+ ~ ")" }
    // inner_infix_term = { commun_base ~ infix_term }

application = {(function | variable) ~ ("(" ~ (term ~ ",")* ~ term? ~ ")")?}
if_then_else = {"if"~ term ~ bracketed_term ~ "else" ~ bracketed_term}
find_such_that = {"try" ~ "find" ~ 
                    typed_arguments ~
                    "such" ~ "that"  ~ bracketed_term ~
                    "then" ~ bracketed_term ~
                    "else" ~ bracketed_term}

quantifier = {quantifier_op ~ typed_arguments ~ bracketed_term }
    quantifier_op = _{exists | forall }
	forall = {"forall"}
    exists = {"exists"}

declaration = { declare_type | declare_function }
    declare_type = {"type" ~ type_name }
    declare_function = {"fun" ~ function ~ declare_function_args ~ 
                          ":" ~ type_name }
       declare_function_args = {("(" ~ (type_name ~ ",")* ~ type_name? ~ ")")?}

step = {"step" ~ step_name ~ typed_arguments ~
         bracketed_term ~ 
         bracketed_term }

assertion = {"assert" ~ term }

assertion_crypto = {"assert-crypto" ~ ident ~ function+ }

query = {"query" ~ term }

lemma = {"lemma" ~ term }

order = {"order" ~ quantifier_op ~ typed_arguments ~ 
    (inner_order | "{" ~ inner_order ~ "}") }
    inner_order = _{application ~ ordering_operation ~ application}
    ordering_operation = _{"<" | "<>" | ">" }